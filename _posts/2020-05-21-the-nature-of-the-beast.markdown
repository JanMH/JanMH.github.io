---
layout: single
title:  "The Nature of The Beast"
date:   2020-05-21 11:38:25 +0200
categories: programming off-my-chest stream-of-consciousness
author: Jan
header:
  overlay_image: /assets/images/st_george_dragon.jpg
---

On programming

Everyone who programs gets to it through a different path. Some of us start out in university not really knowing yet what they are getting themselves into. Others discover it later on and teach themselves, potentially even creating a new career out of it. Others still might take part in a bootcamp with the explicit goal to create a new career. For me, like many others, it started during high school.

 My initial motivation was to become a real hacker after I watched the iconic movie "Hackers" (a must watch if you haven't seen it). The first memory I have of actually having made the decision was talking to my uncle who is originally a lawyer but likes to dabble in Lisp. As I told him about it he gave me the advice to take up C to understand how computers work and not become a so called "script kiddie", something I definitely did not want to become after having read a bit more about the topics on online forums most notably the "Gulli Board", a german language forum and exchange of movie copies and cracked software.

 After I had googled around a bit, I found out that there was an even cooler language called C++. Even the name was more advanced and so I tried out some online tutorials and see how it works. My memory on this initial phase is pretty hazy. All I remember about it is that at some point I gave up on C++ for a while, tried my hands on delphi and then went on to C# without having learned anything about delphi, then back to C++ and so forth.

 Suffice it to say I tried out many things, changed my linux distribution every two weeks and had a lot of fun.

 The fascinating thing for me about remembering my journey is how I built up the knowledge and how the thing I wanted to know and how I viewed them changed. Even now as I work as a professional developer, still my view of what programming is changes. After you have built up the basic building blocks of programming languages, the basic principles of classes, inheritance and maybe a thing or two about how the machine you develop works, the rest is up to you.

 Nothing about how you program is written in stone. You can choose between thousands of programming languages, each giving you a different toolkit to solve your problem. You are confronted with a seemingly infinite catalogue of design patterns and anti patterns and people disagreeing which is which. Only the hardware you target might be a given for you, but most of us develop far to high up the chain for that to make a difference.

 Developers in general seem to love to compare programming to the arts. At least the writers of the books I read do. If I were to make such a comparison I would choose a painter. We look at the world and try to reflect it in our art. Maybe the part we try to reflect might not be as lofty as the concept of afterlife but instead the company internal bureaucratic process of getting a laptop repair there are still similarities. Like painters we use different tools; instead of brushes and types of paint, programming languages, frameworks and data base systems. And like artists in general we have different schools; romanticism vs cubism, impressionism vs expressionism, imperative vs functional, mutexes vs promises vs channels.
 But most importantly, much like with painters, the medium in which we work influences us. While people who use Ruby might be happy to use meta programming to create an impressive amount of functionality in just a few tokens, a Haskell programmer would much rather let the type system guide him to create fault free code.

Some other aspects of programming however do not map well to my comparison. At least not that I can see. While an artist is only limited by his creation (if she is not painting a commissioned work) us programmers have to be careful not to waste the most precious resource on earth: time.
We have to find the balance between "moving fast and breaking things" and creating robust systems.

Another balance we have to make which I think is too often overlooked is happiness vs business needs. I'm not even sure if this is something other professional developers experience but sometimes it makes sense to develop a steaming pile of garbage fast to keep an important client happy, but then later when you have to poke around in that pile you just want to commit suicide. Bonus points if you coworker who left the company years ago developed this. Or an even worse, when you have to support an old service that no one comprehends anymore in it's entirety but it is still used and when inevitable the urgent tickets roll in you have to dig around in said steaming piles of garbage that were developed under hefty time constraints. I guess at some point the company has to decide to pay the client to switch to the new product or for you to change the job. Maybe it is just me being a whiny millennial.

Last but most importantly we will have to find a balance in our conscience. As we are an integral part of the engine that drives technology forward we are responsible for the ethics involved in our work. Of course, everyone needs bread on the table, but we always need to ask ourselves what we are willing to do and where we draw the line. The internet of today is full of tracking, dark design patterns to make you buy things and agree to terms against your interest. I know I did not put them there and let's be completely honest, if I were in a position where I put one of those up on the site or loose my job, it would not be easy to quit. But it is always there in the back of my mind and when the moment comes I will be ready to make the right choice and I hope so will you.
